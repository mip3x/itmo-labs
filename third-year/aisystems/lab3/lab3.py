# -*- coding: utf-8 -*-
"""lab3.ipynb

Automatically generated by Colab.

# Лабораторная №3. Линейная регрессия

## Описание датасета из источника

1. longitude: A measure of how far west a house is; a higher value is farther west

2. latitude: A measure of how far north a house is; a higher value is farther north

3. housingMedianAge: Median age of a house within a block; a lower number is a newer building

4. totalRooms: Total number of rooms within a block

5. totalBedrooms: Total number of bedrooms within a block

6. population: Total number of people residing within a block

7. households: Total number of households, a group of people residing within a home unit, for a block

8. medianIncome: Median income for households within a block of houses (measured in tens of thousands of US Dollars)

9. medianHouseValue: Median house value for households within a block (measured in US Dollars)

10. oceanProximity: Location of the house w.r.t ocean/sea

## Получение данных
"""

import pandas as pd

data = pd.read_csv('/content/housing.csv')
data

"""##  Получение и отображение статистики
Получите и визуализируйте (графически) статистику по датасету (включая количество, среднее значение, стандартное отклонение, минимум, максимум и различные квантили)

### Кодирование категориального признака `ocean_proximity`
Выведем все категории:
"""

data['ocean_proximity'].unique()

"""Признак - мультиклассовый, поэтому введём для каждого элемента из массива новый параметр (столбец)"""

data = pd.get_dummies(
    data,
    columns=['ocean_proximity'],
    drop_first=True
)
bool_cols = data.select_dtypes(include='bool').columns
data[bool_cols] = data[bool_cols].astype(int)

data

statistics = data.describe()
statistics

"""Визуализация"""

data.hist(bins = 100, figsize = (15, 15))

import matplotlib.pyplot as plt
import numpy as np

plt.rcParams['figure.figsize'] = [5, 5]

print('# Количество')
data_count = data.count()
data_count.plot(kind='bar', title='Количество')
print(data_count.to_markdown())
plt.show()

print('# Средние значения признаков')
data_means = data.mean()
data_means.plot(kind='bar', title='Средние значения признаков')
print(data_means.to_markdown())
plt.show()

print('# Стандартные отклонения признаков')
data_std = data.std()
data_std.plot(kind='bar', title='Стандартные отклонения признаков')
print(data_std.to_markdown())
plt.show()

print('# Минимум')
data_min = data.min()
data_min.plot(kind='bar', title='Минимум')
print(data_min.to_markdown())
plt.show()

print('# Максимум')
data_max = data.max()
data_max.plot(kind='bar', title='Максимум')
print(data_max.to_markdown())
plt.show()

"""## Предварительная обработка данных
Проведите предварительную обработку данных, включая обработку отсутствующих значений, кодирование категориальных признаков и нормировка

Выясним, какие столбцы содержат пропуски:
"""

data.isna().sum()

"""Это только столбец `total_bedrooms`. Заменим все отсутствующие данные на медиану, так как медиана устойчива к выбросам:"""

data.fillna({"total_bedrooms": data["total_bedrooms"].median()}, inplace=True)

"""### Нормировка данных
Используем стандартизацию (Z-Score Normalization):

"""

data_norm = data.copy()

for col in data_norm.columns:
    mean = data_norm[col].mean()
    std = data_norm[col].std()
    data_norm[col] = (data_norm[col] - mean) / std
data_norm.hist(bins = 100, figsize = (15, 15))

"""## Добавление синтетического признака"""

data_norm["rooms_per_household"] = data_norm["total_rooms"] / data_norm["households"]

"""## Разделение данных на обучающий и тестовый наборы данных"""

# Определяем зависимую переменную (целевую) и признаки
X = data_norm.drop(columns=['median_house_value']) # ц.п.
y = data_norm['median_house_value']

train_coef = 0.8
random_state = 42

train = data_norm.sample(frac=train_coef, random_state=random_state)
test = data_norm.drop(train.index)

train_x = train.drop(columns=['median_house_value'])
train_y = train['median_house_value']


test_x = test.drop(columns=['median_house_value'])
test_y = test['median_house_value']

print(f"Размер тренировочных данных: {len(train_x)}")
print(f"Размер тестовых данных: {len(test_x)}")

"""## Реализация линейной регрессии с использованием метода наименьших квадратов без использования сторонних библиотек, кроме NumPy и Pandas (для использования коэффициентов использовать библиотеки тоже нельзя). Использовать минимизацию суммы квадратов разностей между фактическими и предсказанными значениями для нахождения оптимальных коэффициентов."""

class LeastSquaresMethod:
    def __init__(self, columns):
        self.columns = list(columns) # признаки, к-ые будут использованы
        self.coef_ = None

    @staticmethod
    def _add_ones(x: np.ndarray) -> np.ndarray:
        # добавление столбца единиц для свободного члена
        ones = np.ones((x.shape[0], 1))
        return np.hstack([ones, x])

    @staticmethod
    def sum_of_squares(true_y, predicted_y) -> float:
        # подсчёт суммы квадратов ошибок
        true_y = np.array(true_y)
        predicted_y = np.array(predicted_y)

        return np.sum((true_y - predicted_y) ** 2)

    @staticmethod
    def r2_score(true_y, predicted_y) -> float:
        # коэф детерминации R^2
        true_y = np.array(true_y)
        predicted_y = np.array(predicted_y)

        mean_y = np.mean(true_y)

        ss_tot = np.sum((true_y - mean_y) ** 2)
        ss_res = np.sum((true_y - predicted_y) ** 2)

        return 1 - ss_res / ss_tot

    def train_model(self, X_df, y_series):
        # обучение модели

        X = np.array(X_df[self.columns])
        y = np.array(y_series)

        X_bias = self._add_ones(X)

        # B = (X^T X)^(-1) X^T y
        XtX = X_bias.T @ X_bias
        XtX_inv = np.linalg.inv(XtX)
        Xty = X_bias.T @ y

        self.coef_ = XtX_inv @ Xty

    def predict(self, X_df):
        if self.coef_ is None:
            raise ValueError("Модель ещё не обучена. Сначала вызовите train_model()")

        X = np.array(X_df[self.columns])
        X_bias = self._add_ones(X)

        return X_bias @ self.coef_

"""## Построение и сравнение трёх моделей с различными наборами признаков"""

model1_cols = [
    "median_income"
]

# минимальная
model2_cols = [
    "median_income",
    "housing_median_age",
    "population"
]

# 5 важных числовых признаков
model3_cols = [
    "median_income",
    "housing_median_age",
    "total_rooms",
    "population",
    "households"
]

# географическая + доход
model4_cols = [
    "longitude",
    "latitude",
    "median_income"
]

# все числовые признаки
model5_cols = [
    "longitude",
    "latitude",
    "housing_median_age",
    "total_rooms",
    "total_bedrooms",
    "population",
    "households",
    "median_income"
]

model6_cols = list(train_x.columns)

model7_cols = [
    "longitude",
    "latitude",
    "housing_median_age",
    "total_rooms",
    "total_bedrooms",
    "population",
    "households",
    "median_income",
    "rooms_per_household"
]

models = {
    "Модель 1 (только доход)": model1_cols,
    "Модель 2 (минимальная)": model2_cols,
    "Модель 3 (5 числовых признаков)": model3_cols,
    "Модель 4 (география + доход)": model4_cols,
    "Модель 5 (все числовые)": model5_cols,
    "Модель 6 (полная: все признаки)": model6_cols,
    "Модель 7 (числов + синтетический признак)": model7_cols
}

results = {}

for name, cols in models.items():
    model = LeastSquaresMethod(cols)
    model.train_model(train_x, train_y)

    pred = model.predict(test_x)

    r2 = LeastSquaresMethod.r2_score(test_y, pred)
    ss = LeastSquaresMethod.sum_of_squares(test_y, pred)

    results[name] = {
        "R2": r2,
        "SS_res": ss,
        "columns": cols
    }

    print(f"\n{name}")
    print("Признаки:", cols)
    print("R^2:", r2)
    print("Сумма квадратов ошибок:", ss)

"""## Анализ результатов
1. Модель 1, основанная только на признаке `median_income`, объясняет около 46% вариации стоимости жилья. Это подтверждает, что доход -- ключевой экономический фактор в формировании цен

2. Модели 2 и 3, использующие дополнительные демографические и жилищные признаки, показывают постепенное увеличение качества до R^2 ~= 0.54, что говорит о полезности структурных характеристик районов

3. Модель 4, включающая географические признаки (longitude, latitude), даёт улучшение качества (R^2 ~= 0.57). География и доход влияют сильнее остальных

4. Полное включение структурных и географических факторов позволяет модели точнее отражать реальную ценовую динамику

5. Модель 6, использующая все признаки и категориальную переменную `ocean_proximity`, показывает илучший результат: R^2 ~= 0.618. Близость района к океану оказывает незначительное влияние на стоимость жилья. Скорее всего, это связано с тем, что географические признаки уже отражают смысл, заключённый в категориальном признаке

6. Модель 7, основанная на числовых признаках + синтетическом признаке `rooms_per_household`, показывает качество, сопоставимое с моделью 5, но хуже модели 6. Синтетический признак не превзошёл вклад категориальных переменных о близости к океану
"""
